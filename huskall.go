package docs

import (
	"bytes"
	"fmt"
	"regexp"
	"strings"
)

var ArgTypes = map[string]string{
	"bool":   "Bool",
	"file":   "ByteString",
	"int":    "Int",
	"string": "Text",
	"uint":   "Word",
}

type HuskallFormatter struct{}

var epParts = regexp.MustCompile("[-/][A-Za-z0-9]")

func endpointName(ep *Endpoint) string {
	return epParts.ReplaceAllStringFunc(ep.Name, func(s string) string {
		return strings.Title(strings.Replace(strings.Replace(s, "/", "", -1), "-", "", -1))
	})
}

func haddock(start string, descr string, indent int) []byte {
	buf := new(bytes.Buffer)

	fmt.Fprintf(buf, start)
	buf0 := new(bytes.Buffer)
	for _, w := range strings.Fields(descr) {
		if buf0.Len()+len(w) > 80 {
			buf.Write(buf0.Bytes())
			fmt.Fprintln(buf)
			for i := 0; i < indent; i++ {
				buf.WriteRune(' ')
			}
			fmt.Fprintf(buf, "-- ")
			buf0.Reset()
		}
		buf0.WriteString(w)
		buf0.WriteRune(' ')
	}
	buf.Write(buf0.Bytes())
	fmt.Fprintln(buf)

	return buf.Bytes()
}

func endpointHaddock(ep *Endpoint) []byte {
	buf := new(bytes.Buffer)
	buf.Write(haddock("-- | ", ep.Description, 0))

	if ep.ResponseTyp != nil {
		fmt.Fprintf(buf, "--\n-- Response example:\n--\n")
		for _, line := range strings.Split(ep.Response, "\n") {
			if len(line) > 0 {
				fmt.Fprintf(buf, "-- > %s\n", line)
			}
		}
	}

	return buf.Bytes()
}

func paramHaddock(arg *Argument) []byte {
	return haddock("-- ", arg.Description, 4)
}

func (hs *HuskallFormatter) GenerateIntro() string {
	buf := new(bytes.Buffer)
	fmt.Fprintln(buf, "{-# LANGUAGE DataKinds     #-}")
	fmt.Fprintln(buf, "{-# LANGUAGE TypeOperators #-}")
	fmt.Fprintln(buf)
	fmt.Fprintln(buf, "-- | AUTOGENERATED")
	fmt.Fprintln(buf, "module Network.IPFS.API where")
	fmt.Fprintln(buf)
	fmt.Fprintln(buf, "import           Data.Aeson (Value)")
	fmt.Fprintln(buf, "import           Data.ByteString (ByteString)")
	fmt.Fprintln(buf, "import qualified Data.ByteString.Lazy as L (ByteString)")
	fmt.Fprintln(buf, "import           Data.Text (Text)")
	fmt.Fprintln(buf, "import           Network.IPFS.API.Types")
	fmt.Fprintln(buf, "import           Servant.API")
	fmt.Fprintln(buf)

	return buf.String()
}

func (hs *HuskallFormatter) GenerateEndpointBlock(endp *Endpoint) string {
	buf := new(bytes.Buffer)

	buf.Write(endpointHaddock(endp))
	fmt.Fprintf(buf, "type %s =\n", endpointName(endp))

	for i, frag := range strings.Split(endp.Name, "/") {
		switch i {
		case 0:
			fmt.Fprintf(buf, "      ")
		case 1:
			fmt.Fprintf(buf, "\"%s\"", frag)
		default:
			fmt.Fprintf(buf, " :> \"%s\"", frag)
		}
	}
	fmt.Fprintln(buf)

	for _, arg := range endp.Arguments {
		if arg.Type == "file" {
			fmt.Fprintf(buf, "    :> ReqBody '[MultipartFormData] L.ByteString\n")
		} else {
			fmt.Fprintf(buf, "    %s", paramHaddock(arg))
			fmt.Fprintf(buf, "    :> QueryParam' '[Required, Strict] \"arg\" %s\n", ArgTypes[arg.Type])
		}
	}

	for _, opt := range endp.Options {
		if opt.Type == "file" {
			fmt.Fprintf(buf, "    :> ReqBody '[MultipartFormData] L.ByteString\n")
		} else {
			fmt.Fprintf(buf, "    %s", paramHaddock(opt))
			fmt.Fprintf(buf, "    :> QueryParam \"%s\" %s\n", opt.Name, ArgTypes[opt.Type])
		}
	}

	if endp.ResponseTyp != nil {
		fmt.Fprintf(buf, "    :> Post '[JSON] Value")
	} else {
		fmt.Fprintf(buf, "    :> Stream 'POST 200 NoFraming PlainText (SourceIO ByteString)")
	}

	fmt.Fprintln(buf)
	fmt.Fprintln(buf)

	return buf.String()
}

// Unneeded stuff

func (hs *HuskallFormatter) GenerateArgumentsBlock(reqs []*Argument, opts []*Argument) string {
	return ""
}

func (hs *HuskallFormatter) GenerateIndex(enps []*Endpoint) string {
	return ""
}

func (hs *HuskallFormatter) GenerateExampleBlock(endp *Endpoint) string {
	return ""
}

func (hs *HuskallFormatter) GenerateBodyBlock(args []*Argument) string {
	return ""
}

func (hs *HuskallFormatter) GenerateResponseBlock(response string) string {
	return ""
}
